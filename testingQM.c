#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorFR,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorFL,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorBR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorBL,       tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C2_1,    hookFL,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_2,    ballDrop,             tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    lift,                 tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_4,    hookFR,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//Last Edited: Meet Patel

void motorCheck(tMotor mtr, int ticks, int power) {
	//cycle motors
	nxtDisplayTextLine(2, "checking motor %s at %d power for %d ticks", mtr, power, ticks);
	nxtDisplayTextLine(4, "m %s at %d pow %d tks", mtr, power, ticks);
	nMotorEncoder[mtr] = 0;
	motor[mtr] = power;
	while (nMotorEncoder[mtr] < ticks) {
		nxtDisplayTextLine(3, "encoder at %d", nMotorEncoder[mtr]);
	}
	motor[mtr] = 0;
	nxtDisplayTextLine(4, "stopped check for motor %s", mtr);
}

void motorCheck(tMotor mtr) {
	motorCheck(mtr, 5000, 100);
}

void haltMotors() {
	//Setting all the motors and encoders to 0
	//nMotorEncoder[motorBL] = 0;
	//nMotorEncoder[motorBR] = 0;
	nMotorEncoder[motorFL] = 0;
	nMotorEncoder[motorFR] = 0;

	motor[motorBL] = 0;
	motor[motorFR] = 0;
	motor[motorBR] = 0;
	motor[motorFL] = 0;
}

void moveTicks(int apple, int direction, int pow) {
	//direction<0 = backwards
	nMotorEncoder[motorFL] = 0;
	nMotorEncoder[motorFR] = 0;

	while (nMotorEncoder[motorFL] < lice && nMotorEncoder[motorFR] < lice) {
		nxtDisplayTextLine(3, "encoder at %d", nMotorEncoder[motorFL]);
		if(direction>0) {
		motor[motorFL] = pow;
		motor[motorFR] = pow;
		motor[motorBL] = pow;
		motor[motorBR] = pow;
	  }
	  else if(direction<0) {
	  motor[motorFL] = -pow;
		motor[motorFR] = -pow;
		motor[motorBL] = -pow;
		motor[motorBR] = -pow;
	  }
	}
	haltMotors();
}

void servoCheck(TServoIndex svo) {
	servo[svo] = 0;
	wait1Msec(1000);
	servo[svo] = 128;
	wait1Msec(1000);
	servo[svo] = -128;
	wait1Msec(1000);
	servo[svo] = 0;
	wait1Msec(1000);
}

void moveLeft(long dest) {

}

task main()
{
	//while (true) {
		//motorCheck(motorBR);
		//motorCheck(motorFR);

		/*nMotorEncoder[motorFL] = 0;
		nMotorEncoder[motorFR] = 0;
		nxtDisplayTextLine(2, "encoder at %d", nMotorEncoder[motorFL]);
		nxtDisplayTextLine(3, "encoder at %d", nMotorEncoder[motorFR]);
		motorCheck(motorFL);
		motor[motorBL] = 100;
		motor[motorFR] = 100;
		motor[motorBR] = 100;
		motor[motorFL] = 100;*/
		//motorCheck(motorFL);
		//motorCheck(motorG);
		//servoCheck(hookFL);
		//servoCheck(hookFR);
		//servoCheck(lift);
		//servoCheck(ballDrop);
		//servo[hookFL] = 30;
		//servo[ballDrop] = 252;
		//servo[hookFR] = 255;
		//servo[lift] = 128;

	//
	moveTicks(100, -1);
	haltMotors();
}
