#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     IR,             sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorPulley,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorNom,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorFL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     motorFR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     motorBL,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     motorBR,       tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    box,                  tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------+
|                                														|
| Last Edited: Meet Patel and Mattori Burn-Baby-Baum 12/30/14
|																														|
+----------------------------------------------------------*/

#include "JoystickDriver.c"

void haltMotors() {
	//Setting all the motors and encoders to 0
	//nMotorEncoder[motorBL] = 0;
	//nMotorEncoder[motorBR] = 0;
	nMotorEncoder[motorFL] = 0;
	nMotorEncoder[motorFR] = 0;

	motor[motorBL] = 0;
	motor[motorFR] = 0;
	motor[motorBR] = 0;
	motor[motorFL] = 0;
}

void forwardMarch(int pwr) {

		motor[motorBL] = pwr;
    motor[motorFL] = pwr;
    motor[motorFR] = pwr;
    motor[motorBR] = pwr;

}

void moveTicks(int pwr, int dir, int ticks){
	//1440 ticks = 1 rotation
  nMotorEncoder[motorFR] = 0;
  nMotorEncoder[motorFL] = 0;
  // abs() lets you use the same program for both forward and backward directions.
  while(abs(nMotorEncoder[motorFL]) < ticks && abs(nMotorEncoder[motorFR]) < ticks){
    if(abs(nMotorEncoder[motorFL]) > abs(nMotorEncoder[motorFR])){ // if the left side is driving faster than the right side
      motor[motorBL] = (pwr-2)*dir;
      motor[motorFL] = (pwr-2)*dir;
      motor[motorFR] = (pwr+2)*dir;
      motor[motorBR] = (pwr+2)*dir;
    }
    else if (abs(nMotorEncoder[motorFR]) > abs(nMotorEncoder[motorFL])){ // if the right side is faster than the left side
      motor[motorBL] = (pwr+2)*dir;
      motor[motorFL] = (pwr+2)*dir;
      motor[motorFR] = (pwr-2)*dir;
      motor[motorBR] = (pwr-2)*dir;
    }
    else {
   	forwardMarch(100);
    }
  }
  haltMotors();
}

void turnTicks(int pwr, int ticks){
	//1440 ticks = 1 rotation
  nMotorEncoder[motorFR] = 0;
  nMotorEncoder[motorFL] = 0;
  // abs() lets you use the same program for both forward and backward directions.
  while(abs(nMotorEncoder[motorFL]) < ticks && abs(nMotorEncoder[motorFR]) < ticks){
    motor[motorFR] = -pwr;
    motor[motorFL] = pwr;
    motor[motorBR] = -pwr;
    motor[motorBL] = pwr;
  }
  haltMotors();
}

void auto1() {
	int dropstart = 80;
	int dropend = 240;
	int openLeft = 180;
	int openRight = 93;
	int closeRight = 147;
	int closeLeft = 129;
	int startRight = 200;
	int startLeft = 30;

	//servo[ballDrop] = dropstart;
	//servo[hookFL] = startLeft;
	//servo[hookFR] = startRight;

	waitForStart();


	//forwards
	moveTicks(30, 1, 2000);

	wait10Msec(50);
	//turn right 45 deg
	turnTicks(30, 1370);
wait10Msec(50);
	moveTicks(30, 1, 1800);
wait10Msec(50);
	//turn left 45 deg
	turnTicks(50, 1380);

	wait10Msec(50);

	moveTicks(70, 1, 5000);

	//get ready to hook
	//servo[hookFL] = openLeft;
	//servo[hookFR] = openRight;

	wait10Msec(50);

	moveTicks(20, 1, 4700);
wait10Msec(100);
	//drop and hook

		//servo[hookFL] = closeLeft;
   // servo[hookFR] = closeRight;


	wait10Msec(75);

		//servo[ballDrop] = dropend;

	wait10Msec(100);

	moveTicks(50, -1, 6000);

	turnTicks(50, 900);

	moveTicks(30, -1, 7000);



	wait10Msec(50);

	turnTicks(-50, 4500);

}

void turnLeft(int ticks) {
	nMotorEncoder[motorFL] = 0;
	nMotorEncoder[motorFR] = 0;
	motor[motorBL] = -100;
	motor[motorBR] = 100;
	motor[motorFL] = -100;
	motor[motorFR] = 100;
}

//TODO correct value for this
const int COEF = 20; //coeff conversion between IR sensor vals and ticks
const int TURN_SPEED = 50;
//Finds the ir beacon
//recurse prevents the robot from repeatedly turning too far to face the right way
void sensIR(int recurse) {
	bool found = false;
	while(!found) {
		while(SensorValue[IR] == 0) {}
		int val = SensorValue[IR]; //wtf is a `word` datatype
		if(val == 5) {
			found = true;
			//TODO this
		} else if(val < 5) {
			turnTicks(TURN_SPEED * -1, (val * COEF) / recurse);
			sensIR(recurse + 1);
		} else {
			turnTicks(TURN_SPEED, (val * COEF) / recurse);
			sensIR(recurse + 1);
		}
	}
}

void sensIR() {
	sensIR(1);
}

void autonomous() {
	//forwardMarch(100);
		//wait1Msec(1700);
		//forwardMarch(0);
	//	int power = 50;
		motor[motorBL] = 50;
			motor[motorBR] = 50;
				motor[motorFL] = 50;
					motor[motorFR] = 50;
					wait10Msec(500);
					motor[motorBL] = 0;
			motor[motorBR] = 0;
				motor[motorFL] = 0;
					motor[motorFR] = 0;

	//0 = pos 3, 3 = pos 2, 1 == pos 1
/*
	switch(SensorValue[IR]) {
	case 1: {
		forwardMarch(100);
		wait1Msec(1400);
		forwardMarch(0);
		motor[motorPulley] = 100;
		wait1Msec(9000);
		motor[motorPulley] = 0;

		break;
	}
	//case 3: {
		//forwardMarch();
		//wait1Msec();
		//forwardMarch();
	//}
	}*/
}

const int THRESHOLD = 27;
task main()
{
	waitForStart();
	//make sure there is a threshold the joystick values have to pass to move the motors
	//the motors might stop if we have values that are too low
	//sautonomous();

	//The manual event loop
 while(true)
  {
	//autonomous();
    getJoystickSettings(joystick);  // Update Buttons and Joysticks

    //nxtDisplayTextLine(3, "j1y1 %d", joystick.joy1_y1);
    //nxtDisplayTextLine(4, "j1y2 %d", joystick.joy1_y2);

    short y1 = joystick.joy1_y1;
    short y2 = joystick.joy1_y2;
     if (joy1Btn(10) == 1 || joy1Btn(11) == 1){
       y1=y1/4;
       y2=y2/4;
     }
    //Threshold is 27 right now see above declaration ^^
    if(abs(y1) < THRESHOLD) {
    	y1 = 0;
  	}

    if(abs(y2) < THRESHOLD) {
    	y2 = 0;
  	}
    motor[motorBL] = y1/1.28;
    motor[motorFL] = y1/1.28;

    motor[motorBR] = y2/1.28;
    motor[motorFR] = y2/1.28;

    nxtDisplayTextLine(1, "y1: %d", joystick.joy1_y1);
    nxtDisplayTextLine(2, "left: %d", motor[motorFL]);
    nxtDisplayTextLine(3, "y2: %d", joystick.joy1_y2);
    nxtDisplayTextLine(4, "right: %d", motor[motorFR]);

    if(joy1Btn(8) == 1) {
    	motor[motorPulley] = 100;
  	} else if(joy1Btn(6) == 1) {
  		motor[motorPulley] = -100;
    } else {
  		motor[motorPulley] = 0;
		}

		if(joy1Btn(7) == 1) {
			motor[motorNom] = 100;
		} else if(joy1Btn(5) == 1) {
			motor[motorNom] = -100;
		} else {
			motor[motorNom] = 0;
		}

    short q1 = joystick.joy2_y1;

    if(abs(q1) < THRESHOLD) {
    	q1 = 0;
  	}
    short q2 = joystick.joy2_y2;
    if(abs(q2) < THRESHOLD) {
    	q2 = 0;
  	}

  	nxtDisplayTextLine(5, "p-in: %d", joystick.joy2_y1);
  	nxtDisplayTextLine(6, "pulley: %d", motor[motorPulley]);
		nxtDisplayTextLine(7, "sensor value: %d", SensorValue[IR]);

  	}
}
