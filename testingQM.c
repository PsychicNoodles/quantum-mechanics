#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorFR,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorFL,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorBR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorBL,       tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    ballDrop,             tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    lift,                 tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_4,    hookFR,               tServoStandard)
#pragma config(Servo,  srvo_S1_C2_5,    hookFL,               tServoStandard)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Last Edited: Meet Patel 10/14/14


#include "JoystickDriver.c"

void motorCheck(tMotor mtr, int ticks, int power) {
	//cycle motors
	nxtDisplayTextLine(2, "checking motor %s at %d power for %d ticks", mtr, power, ticks);
	nxtDisplayTextLine(4, "m %s at %d pow %d tks", mtr, power, ticks);
	nMotorEncoder[mtr] = 0;
	motor[mtr] = power;
	while (nMotorEncoder[mtr] < ticks) {
		nxtDisplayTextLine(3, "encoder at %d", nMotorEncoder[mtr]);
	}
	motor[mtr] = 0;
	nxtDisplayTextLine(4, "stopped check for motor %s", mtr);
}

void motorCheck(tMotor mtr) {
	motorCheck(mtr, 5000, 100);
}

void haltMotors() {
	//Setting all the motors and encoders to 0
	//nMotorEncoder[motorBL] = 0;
	//nMotorEncoder[motorBR] = 0;
	nMotorEncoder[motorFL] = 0;
	nMotorEncoder[motorFR] = 0;

	motor[motorBL] = 0;
	motor[motorFR] = 0;
	motor[motorBR] = 0;
	motor[motorFL] = 0;
}

void forwardMarch(int pow, int dir) {
	 	motor[motorBL] = (pow)*dir;
    motor[motorFL] = (pow)*dir;
    motor[motorFR] = (pow)*dir;
    motor[motorBR] = (pow)*dir;
}

void moveTicks(int pow, int dir, int ticks){
	//1440 ticks = 1 rotation
  nMotorEncoder[motorFR] = 0;
  nMotorEncoder[motorFL] = 0;
  // abs() lets you use the same program for both forward and backward directions.
  while(abs(nMotorEncoder[motorFL]) < ticks && abs(nMotorEncoder[motorFR]) < ticks){
    if(abs(nMotorEncoder[motorFL]) > abs(nMotorEncoder[motorFR])){ // if the left side is driving faster than the right side
      motor[motorBL] = (pow-2)*dir;
      motor[motorFL] = (pow-2)*dir;
      motor[motorFR] = (pow+2)*dir;
      motor[motorBR] = (pow+2)*dir;
    }
    else if (abs(nMotorEncoder[motorFR]) > abs(nMotorEncoder[motorFL])){ // if the right side is faster than the left side
      motor[motorBL] = (pow+2)*dir;
      motor[motorFL] = (pow+2)*dir;
      motor[motorFR] = (pow-2)*dir;
      motor[motorBR] = (pow-2)*dir;
    }
    else {
   	forwardMarch(100,1);
    }
  }
  haltMotors();
}

void turnTicks(int pow, int dir, int ticks){
	//1440 ticks = 1 rotation
  nMotorEncoder[motorFR] = 0;
  nMotorEncoder[motorFL] = 0;
  // abs() lets you use the same program for both forward and backward directions.
  while(abs(nMotorEncoder[motorFL]) < ticks && abs(nMotorEncoder[motorFR]) < ticks){
    motor[motorFR] = -pow*dir;
    motor[motorFL] = pow*dir;
    motor[motorBR] = -pow*dir;
    motor[motorBL] = pow*dir;
  }
  haltMotors();
}


void servoCheck(TServoIndex svo) {
	servo[svo] = 0;
	wait1Msec(1000);
	servo[svo] = 128;
	wait1Msec(1000);
	servo[svo] = -128;
	wait1Msec(1000);
	servo[svo] = 0;
	wait1Msec(1000);
}

void moveLeft(long dest) {

}

task main()
{
	int dropstart = 80;
	int dropend = 240;
	int openLeft = 180;
	int openRight = 93;
	int closeRight = 147;
	int closeLeft = 129;
	int startRight = 200;
	int startLeft = 30;

	servo[ballDrop] = dropstart;
	servo[hookFL] = startLeft;
	servo[hookFR] = startRight;

	waitForStart();


	//forwards
	moveTicks(30, 1, 2000);

	wait10Msec(50);
	//turn right 45 deg
	turnTicks(30, 1, 1370);
wait10Msec(50);
	moveTicks(30, 1, 1800);
wait10Msec(50);
	//turn left 45 deg
	turnTicks(50, -1, 1380);

	wait10Msec(50);

	moveTicks(70, 1, 5000);

	//get ready to hook
	servo[hookFL] = openLeft;
	servo[hookFR] = openRight;

	wait10Msec(50);

	moveTicks(20, 1, 4700);
wait10Msec(100);
	//drop and hook

	servo[hookFL] = closeLeft;
	servo[hookFR] = closeRight;


	wait10Msec(75);

		servo[ballDrop] = dropend;

	wait10Msec(100);

	moveTicks(50, -1, 6000);

	turnTicks(50, 1, 900);

	moveTicks(30, -1, 7000);



	wait10Msec(50);

	turnTicks(50, -1, 4500);


}
