#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     US,             sensorSONAR)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorPulley,   tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorNom,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorFL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     motorFR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     motorBL,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     motorBR,       tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    box,                  tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------+
|                                														|
| Last Edited: Meet Patel and Mattori Burn-Baby-Baum 12/30/14
|																														|
+----------------------------------------------------------*/

#include "JoystickDriver.c"

//Constants
const int THRESHOLD = 27;
//if whichAuto = false, we will run the ramp autonomous code
const bool whichAuto = true;

void turnLeft(int ticks) {
	//nMotorEncoder[motorFL] = 0;
	//nMotorEncoder[motorFR] = 0;
	motor[motorBL] = -100;
	motor[motorBR] = 100;
	motor[motorFL] = -100;
	motor[motorFR] = 100;
	wait1Msec(ticks);
	motor[motorBL] = 0;
	motor[motorBR] = 0;
	motor[motorFL] = 0;
	motor[motorFR] = 0;
}

void turnRight(int ticks) {
	motor[motorBL] = 100;
	motor[motorBR] = -100;
	motor[motorFL] = 100;
	motor[motorFR] = -100;
	wait1Msec(ticks);
	motor[motorBL] = 0;
	motor[motorBR] = 0;
	motor[motorFL] = 0;
	motor[motorFR] = 0;
}

//TODO correct value for this
//Finds the ir beacon
//recurse prevents the robot from repeatedly turning too far to face the right way
/*void sensIR(int recurse) {
	bool found = false;
	while(!found) {
		while(SensorValue[IR] == 0) {}
		int val = SensorValue[IR]; //wtf is a `word` datatype
		if(val == 5) {
			found = true;
			//TODO this
		} else if(val < 5) {
			turnTicks(TURN_SPEED * -1, (val * COEF) / recurse);
			sensIR(recurse + 1);
		} else {
			turnTicks(TURN_SPEED, (val * COEF) / recurse);
			sensIR(recurse + 1);
		}
	}
}*/

/*void sensIR() {
	sensIR(1);
}*/

void backwards(int duration, int speed) {
	motor[motorBL] = speed;
	motor[motorBR] = speed;
	motor[motorFL] = speed;
	motor[motorFR] = speed;
	wait1Msec(duration);
	motor[motorBL] = 0;
	motor[motorBR] = 0;
	motor[motorFL] = 0;
	motor[motorFR] = 0;
}

void autonomous() {
	//forwardMarch(100);
		//wait1Msec(1700);
		//forwardMarch(0);
	//	int power = 50;
if(whichAuto){
backwards(1330, -50);
motor[motorPulley] = 100;
wait1Msec(8000);
motor[motorPulley] = 0;
wait1Msec(500);
servo[box] = 255;
wait1Msec(2000);
	/*	motor[motorBL] = -50;
		motor[motorBR] = -50;
		motor[motorFL] = -50;
		motor[motorFR] = -50;
		wait1Msec(1100);
		motor[motorBL] = 0;
		motor[motorBR] = 0;
		motor[motorFL] = 0;
		motor[motorFR] = 0;*/

		//NEED TO REPLACE TIME VALUES WITH ENCODER VALUES
		/*int min = 255;
		for(int i = 0; i < 10; i++) {
			int current = SensorValue[US];
			min = min < current ? min : current;
			wait1Msec(100);
		}*/
		//~36 = pos 1, 255 = pos 2, ~63 = pos 3
		/*if(min > 30 && min < 40) {
			backwards(400, -50);
		} else if(min == 255) {
			turnLeft(680);
			wait1Msec(50);
			backwards(1450, -50);
			wait1Msec(50);
			turnRight(1020);
			wait1Msec(50);
			backwards(950, -50);
		} else {
			turnLeft(680);
			wait1Msec(50);
			backwards(1500, -50);
			wait1Msec(50);
			turnRight(680);
			wait1Msec(50);
			backwards(1270, -50);
			wait1Msec(50);
			turnRight(690);
			wait1Msec(50);
			backwards(400, -50);
		}*/
	}
	else backwards(1900, -80);
/*
	switch(SensorValue[IR]) {
	case 1: {
		forwardMarch(100);
		wait1Msec(1400);
		forwardMarch(0);
		motor[motorPulley] = 100;
		wait1Msec(9000);
		motor[motorPulley] = 0;

		break;
	}
	//case 3: {
		//forwardMarch();
		//wait1Msec();
		//forwardMarch();
	//}
	}*/
}


task main()
{
	waitForStart();
	//make sure there is a threshold the joystick values have to pass to move the motors
	//the motors might stop if we have values that are too low
	//sautonomous();

	autonomous();
	//The manual event loop
	bool started = false;
 while(true)
  {
    getJoystickSettings(joystick);  // Update Buttons and Joysticks

    //nxtDisplayTextLine(3, "j1y1 %d", joystick.joy1_y1);
    //nxtDisplayTextLine(4, "j1y2 %d", joystick.joy1_y2);

    //i drive...
    switch(joystick.joy1_TopHat) {
   		case 7: case 0: case 1: if(started) { motor[motorBL] = 20; motor[motorBR] = 20; motor[motorFL] = 20; motor[motorFR] = 20; } break;
   		case 3: case 4: case 5: motor[motorBL] = -20; motor[motorBR] = -20; motor[motorFL] = -20; motor[motorFR] = -20; break;
   		default:
   			short y1 = joystick.joy1_y1;
		    short y2 = joystick.joy1_y2;
		    //Threshold is 27 right now see above declaration ^^
		    if(abs(y1) < THRESHOLD) {
		    	y1 = 0;
		    	started = true;
		  	}

		    if(abs(y2) < THRESHOLD) {
		    	y2 = 0;
		    	started = true;
		  	}
		    motor[motorBL] = y1/1.28;
		    motor[motorFL] = y1/1.28;

		    motor[motorBR] = y2/1.28;
		    motor[motorFR] = y2/1.28;
  	}

    nxtDisplayTextLine(1, "y1: %d", joystick.joy1_y1);
    nxtDisplayTextLine(2, "left: %d", motor[motorFL]);
    nxtDisplayTextLine(3, "y2: %d", joystick.joy1_y2);
    nxtDisplayTextLine(4, "right: %d", motor[motorFR]);

    //GÜNthER
    short tophat = joystick.joy2_TopHat;
    switch(tophat) {
    	case 7: case 0: case 1: if(started) { motor[motorPulley] = 100; } break;
    	case 3: case 4: case 5: motor[motorPulley] = -40;  break;
    	default: motor[motorPulley] = 0;
  	}

		if(joy2Btn(5) == 1) {
			motor[motorNom] = 60;
			started = true;
		}
		else if(joy2Btn(4) == 1) {
			motor[motorNom] = 100;
			started = true;
		}
		else {
			motor[motorNom] = 0;
		}

  	if(joy2Btn(2) == 1) {
  		servo[box] = 255;
  		wait1Msec(50);
  	}
  	else servo[box] = 0;



  	//nxtDisplayTextLine(5, "p-in: %d", joystick.joy2_y1);
  	nxtDisplayTextLine(6, "pulley: %d", motor[motorPulley]);
		nxtDisplayTextLine(7, "encoder: %d", nMotorEncoder[motorPulley]);

  	}
}

/**
* ACTUAL BUTTON MAPPINGS
start = 8
back = 7
RB = 6
LB = 5
Y = 4
B = 3
A = 2
X = 1

*/
